#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "json"
require "fileutils"
require "net/http"
require "socket"
require "time"
require "uri"

ROOT = File.expand_path("..", __dir__)
PID_DIR = File.join(ROOT, "tmp", "pids")
STATE_FILE = File.join(PID_DIR, "dev_services.json")
APP_TOKEN = File.basename(ROOT).downcase

SIDEKIQ_QUIET_SECONDS = Integer(ENV.fetch("SIDEKIQ_QUIET_SECONDS", "8"))
STOP_TIMEOUT_SECONDS = Integer(ENV.fetch("DEV_STOP_TIMEOUT_SECONDS", "30"))
PORT_RELEASE_TIMEOUT_SECONDS = Integer(ENV.fetch("DEV_PORT_RELEASE_TIMEOUT_SECONDS", "12"))
SERVICE_LOG_DIR = File.join(ROOT, "log", "dev_services")
WEB_PORT = Integer(ENV.fetch("PORT", "3000"))
DEV_ATTACH_TTY = ENV.fetch("DEV_ATTACH_TTY", "false") == "true"
WEB_HEALTHCHECK_ENABLED = ENV.fetch("DEV_WEB_HEALTHCHECK_ENABLED", "true") == "true"
WEB_HEALTHCHECK_INTERVAL_SECONDS = ENV.fetch("DEV_WEB_HEALTHCHECK_INTERVAL_SECONDS", "5").to_f.clamp(1.0, 30.0)
WEB_HEALTHCHECK_TIMEOUT_SECONDS = ENV.fetch("DEV_WEB_HEALTHCHECK_TIMEOUT_SECONDS", "1.5").to_f.clamp(0.2, 10.0)
WEB_HEALTHCHECK_FAILURE_THRESHOLD = Integer(ENV.fetch("DEV_WEB_HEALTHCHECK_FAILURE_THRESHOLD", "3")).clamp(1, 10)
LOCAL_AI_READY_TIMEOUT_SECONDS = Integer(ENV.fetch("DEV_LOCAL_AI_READY_TIMEOUT_SECONDS", "90")).clamp(5, 600)
LOCAL_AI_HTTP_OPEN_TIMEOUT_SECONDS = ENV.fetch("DEV_LOCAL_AI_HTTP_OPEN_TIMEOUT_SECONDS", "1.5").to_f.clamp(0.2, 10.0)
LOCAL_AI_HTTP_READ_TIMEOUT_SECONDS = ENV.fetch("DEV_LOCAL_AI_HTTP_READ_TIMEOUT_SECONDS", "2.5").to_f.clamp(0.2, 15.0)
LOCAL_AI_SERVICE_URL = ENV.fetch("LOCAL_AI_SERVICE_URL", "http://localhost:8000")
OLLAMA_URL = ENV.fetch("OLLAMA_URL", "http://localhost:11434")

Service = Struct.new(:name, :cmd, :match_token, :pid, :pgid, keyword_init: true)

def log(message)
  puts("[dev] #{message}")
end

def warn_log(message)
  puts("[dev][warn] #{message}")
end

def error_log(message)
  warn("[dev][error] #{message}")
end

def bool_env(value, default: false)
  text = value.to_s.strip.downcase
  return default if text.empty?

  return true if %w[1 true yes on].include?(text)
  return false if %w[0 false no off].include?(text)

  default
end

def local_ai_mode
  raw = ENV.fetch("START_LOCAL_AI", "auto").to_s.strip.downcase
  return "enabled" if %w[1 true yes on].include?(raw)
  return "disabled" if %w[0 false no off].include?(raw)

  "auto"
end

def local_ai_required?
  mode = local_ai_mode
  return false if mode == "disabled"
  return true if mode == "enabled"

  bool_env(ENV.fetch("USE_LOCAL_AI_MICROSERVICE", "true"), default: true)
end

def process_alive?(pid)
  return false if pid.to_i <= 0

  Process.kill(0, pid.to_i)
  true
rescue Errno::ESRCH
  false
rescue Errno::EPERM
  true
end

def process_state(pid)
  return nil unless process_alive?(pid)

  status_path = "/proc/#{pid.to_i}/status"
  return nil unless File.exist?(status_path)

  line = File.foreach(status_path).find { |row| row.start_with?("State:") }
  return nil unless line

  line.split[1].to_s
rescue StandardError
  nil
end

def command_line(pid)
  return "" unless process_alive?(pid)

  `ps -o command= -p #{pid.to_i}`.to_s.strip
rescue StandardError
  ""
end

def process_matches?(pid, token)
  return false unless process_alive?(pid)
  return true if token.to_s.strip.empty?

  command_line(pid).include?(token)
end

def send_signal_to_service(service, signal)
  pid = service.pid.to_i
  return false unless process_alive?(pid)

  pgid = service.pgid.to_i
  if pgid.positive?
    Process.kill(signal, -pgid)
  else
    Process.kill(signal, pid)
  end
  true
rescue Errno::ESRCH
  false
end

def send_signal(signal, pid:, pgid: nil)
  return false unless process_alive?(pid)

  target = pgid.to_i.positive? ? -pgid.to_i : pid.to_i
  Process.kill(signal, target)
  true
rescue Errno::ESRCH
  false
end

def wait_until(timeout_seconds:)
  deadline = Time.now + timeout_seconds.to_f
  until Time.now >= deadline
    return true if yield

    sleep(0.2)
  end
  yield
end

def wait_for_services_exit(services, timeout_seconds:)
  wait_until(timeout_seconds: timeout_seconds) do
    services.none? { |service| process_alive?(service.pid) }
  end
end

def reap_children(services)
  services.each do |service|
    pid = service.pid.to_i
    next if pid <= 0

    begin
      Process.waitpid(pid, Process::WNOHANG)
    rescue Errno::ECHILD, Errno::ESRCH
      next
    end
  end
end

def wait_for_port_release(port, timeout_seconds:)
  return true if port.to_i <= 0

  wait_until(timeout_seconds: timeout_seconds) { !port_open?(port) }
end

def terminate_pid_with_escalation(pid:, label:, quiet_first: false, pgid: nil, timeout_seconds: STOP_TIMEOUT_SECONDS)
  return true unless process_alive?(pid)

  if quiet_first
    log("Sending TSTP to #{label} PID #{pid}")
    send_signal("TSTP", pid: pid, pgid: pgid)
    sleep(SIDEKIQ_QUIET_SECONDS)
  end

  log("Sending TERM to #{label} PID #{pid}")
  send_signal("TERM", pid: pid, pgid: pgid)
  stopped = wait_until(timeout_seconds: timeout_seconds) { !process_alive?(pid) }
  return true if stopped

  warn_log("Escalating to KILL for #{label} PID #{pid}")
  send_signal("KILL", pid: pid, pgid: pgid)
  wait_until(timeout_seconds: 5) { !process_alive?(pid) }
end

def process_rows_for_current_user
  user = ENV.fetch("USER", "")
  rows = `ps -u #{user} -o pid=,ppid=,command=`.to_s.lines
  rows.filter_map do |line|
    stripped = line.to_s.strip
    next if stripped.empty?

    parts = stripped.split(/\s+/, 3)
    next if parts.length < 3

    { pid: parts[0].to_i, ppid: parts[1].to_i, command: parts[2].to_s }
  end
rescue StandardError
  []
end

def sidekiq_pids_for_app
  process_rows_for_current_user
    .select do |row|
      cmd = row[:command].to_s.downcase
      row[:pid].positive? &&
        cmd.include?("sidekiq") &&
        (cmd.include?(APP_TOKEN) || cmd.include?("config/sidekiq.yml"))
    end
    .map { |row| row[:pid] }
    .uniq
end

def asset_watcher_pids_for_app
  process_rows_for_current_user
    .select do |row|
      cmd = row[:command].to_s
      down = cmd.downcase
      row[:pid].positive? &&
        cmd.include?(ROOT) &&
        (
          down.include?("webpack serve --config webpack.config.js") ||
          down.include?("node_modules/.bin/sass") ||
          down.include?("yarn dev:server") ||
          down.include?("yarn build:css --watch")
        )
    end
    .map { |row| row[:pid] }
    .uniq
end

def rails_server_process_for_app?(pid)
  cmd = command_line(pid).to_s.downcase
  return false if cmd.empty?

  (cmd.include?("puma") || cmd.include?("bin/rails server")) && cmd.include?(APP_TOKEN)
end

def stop_rails_from_pidfile(pidfile:, timeout_seconds: STOP_TIMEOUT_SECONDS)
  return false unless File.exist?(pidfile)

  raw = File.read(pidfile).to_s.strip
  pid = Integer(raw)
  unless process_alive?(pid)
    warn_log("Removing stale Rails pid file at #{pidfile}")
    File.delete(pidfile)
    return false
  end

  unless rails_server_process_for_app?(pid)
    warn_log("PID #{pid} from #{pidfile} is not this app's Rails server. Removing stale pid file.")
    File.delete(pidfile)
    return false
  end

  stopped = terminate_pid_with_escalation(
    pid: pid,
    label: "rails",
    quiet_first: false,
    timeout_seconds: timeout_seconds
  )
  if stopped
    File.delete(pidfile) if File.exist?(pidfile)
    wait_for_port_release(3000, timeout_seconds: PORT_RELEASE_TIMEOUT_SECONDS)
  end
  stopped
rescue ArgumentError
  warn_log("Removing invalid Rails pid file at #{pidfile}")
  File.delete(pidfile) if File.exist?(pidfile)
  false
end

def stop_untracked_local_services
  stopped_any = false

  pidfile = File.join(ROOT, "tmp", "pids", "server.pid")
  stopped_any ||= stop_rails_from_pidfile(pidfile: pidfile, timeout_seconds: 15)

  sidekiq_pids_for_app.each do |pid|
    stopped = terminate_pid_with_escalation(
      pid: pid,
      label: "sidekiq",
      quiet_first: true,
      timeout_seconds: 20
    )
    stopped_any ||= stopped
  end

  asset_watcher_pids_for_app.each do |pid|
    stopped = terminate_pid_with_escalation(
      pid: pid,
      label: "asset_watcher",
      quiet_first: false,
      timeout_seconds: 10
    )
    stopped_any ||= stopped
  end

  stopped_any
end

def port_open?(port)
  Socket.tcp("127.0.0.1", Integer(port), connect_timeout: 0.25) { true }
rescue StandardError
  false
end

def parse_port_from_url(url, default_port)
  uri = URI.parse(url.to_s)
  Integer(uri.port || default_port)
rescue StandardError
  Integer(default_port)
end

def port_listener_hint(port)
  return nil if port.to_i <= 0

  row = `ss -ltnp 'sport = :#{port.to_i}' 2>/dev/null | tail -n +2 | head -n 1`.to_s.strip
  row.empty? ? nil : row
rescue StandardError
  nil
end

def fetch_json(url, path:, open_timeout:, read_timeout:)
  uri = URI.parse(url.to_s)
  uri.path = path
  uri.query = nil

  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = uri.scheme == "https"
  http.open_timeout = open_timeout
  http.read_timeout = read_timeout

  request = Net::HTTP::Get.new(uri.request_uri)
  response = http.request(request)
  body = response.body.to_s
  data = body.empty? ? {} : JSON.parse(body)
  { status_code: response.code.to_i, data: data }
rescue StandardError => e
  { error: "#{e.class}: #{e.message}" }
end

def local_ai_health_snapshot
  micro = fetch_json(
    LOCAL_AI_SERVICE_URL,
    path: "/health",
    open_timeout: LOCAL_AI_HTTP_OPEN_TIMEOUT_SECONDS,
    read_timeout: LOCAL_AI_HTTP_READ_TIMEOUT_SECONDS
  )
  ollama = fetch_json(
    OLLAMA_URL,
    path: "/api/tags",
    open_timeout: LOCAL_AI_HTTP_OPEN_TIMEOUT_SECONDS,
    read_timeout: LOCAL_AI_HTTP_READ_TIMEOUT_SECONDS
  )

  micro_ok = micro[:status_code] == 200 && micro.dig(:data, "status").to_s == "healthy"
  ollama_ok = ollama[:status_code] == 200 && ollama.dig(:data, "models").is_a?(Array)

  {
    ok: micro_ok && ollama_ok,
    microservice_ok: micro_ok,
    ollama_ok: ollama_ok,
    microservice_error: micro[:error],
    ollama_error: ollama[:error],
    microservice_status_code: micro[:status_code],
    ollama_status_code: ollama[:status_code],
    microservice_url: LOCAL_AI_SERVICE_URL,
    ollama_url: OLLAMA_URL
  }
end

def wait_for_local_ai_ready(timeout_seconds:)
  latest = nil
  ready = wait_until(timeout_seconds: timeout_seconds) do
    latest = local_ai_health_snapshot
    latest[:ok]
  end
  [ready, latest || local_ai_health_snapshot]
end

def ensure_local_ai_before_jobs
  required = local_ai_required?
  mode = local_ai_mode
  initial = local_ai_health_snapshot

  if initial[:ok]
    log("Local AI ready (mode=#{mode}, ownership=external)")
    return {
      "mode" => mode,
      "required" => required,
      "owned" => false,
      "ready" => true,
      "preexisting" => true,
      "snapshot" => initial
    }
  end

  if required
    log("Local AI not ready; attempting startup via bin/local_ai_services")
    started = system("bin/local_ai_services", "start", chdir: ROOT)
    ready, snapshot = wait_for_local_ai_ready(timeout_seconds: LOCAL_AI_READY_TIMEOUT_SECONDS)
    unless started && ready
      micro_port = parse_port_from_url(LOCAL_AI_SERVICE_URL, 8000)
      ollama_port = parse_port_from_url(OLLAMA_URL, 11434)
      warn_log("Microservice listener hint (port #{micro_port}): #{port_listener_hint(micro_port) || 'none'}")
      warn_log("Ollama listener hint (port #{ollama_port}): #{port_listener_hint(ollama_port) || 'none'}")
      error_log(
        "Local AI is required but not healthy. " \
        "microservice_ok=#{snapshot[:microservice_ok]} ollama_ok=#{snapshot[:ollama_ok]} " \
        "microservice_error=#{snapshot[:microservice_error] || 'none'} " \
        "ollama_error=#{snapshot[:ollama_error] || 'none'}"
      )
      raise "Local AI services failed readiness checks"
    end

    log("Local AI ready (mode=#{mode}, ownership=managed)")
    return {
      "mode" => mode,
      "required" => required,
      "owned" => true,
      "ready" => true,
      "preexisting" => false,
      "snapshot" => snapshot
    }
  end

  warn_log("Local AI not ready, continuing (mode=#{mode}, required=false)")
  {
    "mode" => mode,
    "required" => required,
    "owned" => false,
    "ready" => false,
    "preexisting" => false,
    "snapshot" => initial
  }
end

def build_services(rails_args)
  env_path = ENV.fetch("PATH", "")
  ffmpeg_bin = ENV.fetch("FFMPEG_BIN", "$HOME/.local/bin/ffmpeg")
  debug_open = ENV["RUBY_DEBUG_OPEN"].to_s

  [
    Service.new(
      name: "web",
      cmd: [
        "env",
        "PATH=#{env_path}",
        "WEBPACK_DEV_SERVER=true",
        ("RUBY_DEBUG_OPEN=#{debug_open}" unless debug_open.empty?),
        "FFMPEG_BIN=#{ffmpeg_bin}",
        "bin/rails",
        "server",
        *rails_args
      ].compact,
      match_token: "bin/rails server"
    ),
    Service.new(
      name: "worker",
      cmd: ["env", "PATH=#{env_path}", "FFMPEG_BIN=#{ffmpeg_bin}", "bundle", "exec", "sidekiq", "-C", "config/sidekiq.yml"],
      match_token: "sidekiq"
    ),
    Service.new(
      name: "js",
      cmd: ["env", "PATH=#{env_path}", "yarn", "dev:server"],
      match_token: "yarn dev:server"
    ),
    Service.new(
      name: "css",
      cmd: ["env", "PATH=#{env_path}", "yarn", "build:css", "--watch"],
      match_token: "yarn build:css --watch"
    )
  ]
end

def write_state(supervisor_pid:, services:, local_ai: nil)
  FileUtils.mkdir_p(PID_DIR)
  local_ai_payload = local_ai.is_a?(Hash) ? local_ai : {}
  local_ai_owned = bool_env(local_ai_payload["owned"], default: false)
  payload = {
    "supervisor_pid" => supervisor_pid,
    "local_ai_started" => local_ai_owned,
    "local_ai" => local_ai_payload,
    "started_at" => Time.now.utc.iso8601,
    "services" => services.to_h do |service|
      [
        service.name,
        {
          "pid" => service.pid,
          "pgid" => service.pgid,
          "match_token" => service.match_token,
          "cmd" => service.cmd
        }
      ]
    end
  }
  File.write(STATE_FILE, JSON.pretty_generate(payload))
end

def remove_state
  File.delete(STATE_FILE) if File.exist?(STATE_FILE)
rescue StandardError
  nil
end

def read_state
  return nil unless File.exist?(STATE_FILE)

  JSON.parse(File.read(STATE_FILE))
rescue StandardError => e
  warn_log("Failed to read state file: #{e.class}: #{e.message}")
  nil
end

def services_from_state(state)
  raw = state.is_a?(Hash) ? state["services"] : nil
  return [] unless raw.is_a?(Hash)

  raw.map do |name, attrs|
    attrs ||= {}
    Service.new(
      name: name.to_s,
      cmd: Array(attrs["cmd"]),
      match_token: attrs["match_token"].to_s,
      pid: attrs["pid"].to_i,
      pgid: attrs["pgid"].to_i
    )
  end
end

def stop_local_ai_if_started(state)
  return unless state.is_a?(Hash)
  local_ai_state = state["local_ai"].is_a?(Hash) ? state["local_ai"] : {}
  local_ai_owned = if state.key?("local_ai_started")
    bool_env(state["local_ai_started"], default: false)
  else
    bool_env(local_ai_state["owned"], default: false)
  end
  return unless local_ai_owned

  log("Stopping local AI services")
  system("bin/local_ai_services", "stop", chdir: ROOT)
end

def signalable_service?(service, strict_match:)
  return false unless process_alive?(service.pid)
  return true unless strict_match

  process_matches?(service.pid, service.match_token)
end

def graceful_stop_services(services, reason:, strict_match: false)
  return if services.empty?

  log("Stopping services (#{reason})")

  worker = services.find { |service| service.name == "worker" }
  if worker && signalable_service?(worker, strict_match: strict_match)
    log("Quieting Sidekiq worker PID #{worker.pid} before shutdown")
    send_signal_to_service(worker, "TSTP")
    sleep(SIDEKIQ_QUIET_SECONDS)
  end

  services.each do |service|
    next unless signalable_service?(service, strict_match: strict_match)

    log("Sending TERM to #{service.name} PID #{service.pid}")
    send_signal_to_service(service, "TERM")
  end

  exited = wait_for_services_exit(services, timeout_seconds: STOP_TIMEOUT_SECONDS)
  unless exited
    services.each do |service|
      next unless process_alive?(service.pid)

      warn_log("Escalating to KILL for #{service.name} PID #{service.pid}")
      send_signal_to_service(service, "KILL")
    end
    wait_for_services_exit(services, timeout_seconds: 5)
  end

  reap_children(services)
  wait_for_port_release(3000, timeout_seconds: PORT_RELEASE_TIMEOUT_SECONDS)
end

def stop_from_state
  state = read_state
  unless state
    stopped_any = stop_untracked_local_services
    if stopped_any
      log("Stopped untracked local Rails/Sidekiq services for this app.")
    else
      log("No dev state file found. Nothing to stop.")
    end
    return
  end

  supervisor_pid = state["supervisor_pid"].to_i
  if supervisor_pid.positive? && process_alive?(supervisor_pid)
    log("Requesting supervisor shutdown (PID #{supervisor_pid})")
    Process.kill("INT", supervisor_pid)
    stopped = wait_until(timeout_seconds: STOP_TIMEOUT_SECONDS) do
      !process_alive?(supervisor_pid) || !File.exist?(STATE_FILE)
    end
    if stopped
      log("Supervisor stopped cleanly")
      return
    end
    warn_log("Supervisor did not stop in time. Forcing direct service shutdown.")
  end

  services = services_from_state(state)
  strict_match = !process_alive?(supervisor_pid)
  graceful_stop_services(services, reason: "external stop", strict_match: strict_match)
  stop_local_ai_if_started(state)
  remove_state
end

def status_from_state
  state = read_state
  unless state
    log("No running dev supervisor found")
    return
  end

  supervisor_pid = state["supervisor_pid"].to_i
  supervisor_status = process_alive?(supervisor_pid) ? "running" : "not-running"
  log("Supervisor PID #{supervisor_pid}: #{supervisor_status}")

  services = services_from_state(state)
  services.each do |service|
    alive = process_alive?(service.pid)
    matches = alive && process_matches?(service.pid, service.match_token)
    status = alive ? (matches ? "running" : "pid-reused") : "stopped"
    log("#{service.name.ljust(8)} pid=#{service.pid} status=#{status}")
  end
end

def spawn_service(service)
  pid = Process.spawn(*service.cmd, chdir: ROOT, pgroup: true, in: File::NULL)
  service.pid = pid
  service.pgid = pid
  log("Started #{service.name} PID #{pid}")
end

def start_stack(rails_args)
  stop_from_state if File.exist?(STATE_FILE)
  ensure_rails_pidfile_consistency!

  local_ai_state = ensure_local_ai_before_jobs

  log("Building assets")
  system("yarn", "build", chdir: ROOT) || warn_log("JavaScript build failed")
  system("yarn", "build:css", chdir: ROOT) || warn_log("CSS build failed")

  services = build_services(rails_args)
  services.each { |service| spawn_service(service) }

  write_state(supervisor_pid: Process.pid, services: services, local_ai: local_ai_state)

  shutdown_signal = nil
  Signal.trap("INT") { shutdown_signal ||= "INT" }
  Signal.trap("TERM") { shutdown_signal ||= "TERM" }
  last_web_state = nil
  web_stopped_cycles = 0

  loop do
    if shutdown_signal
      graceful_stop_services(services, reason: "signal #{shutdown_signal}")
      stop_local_ai_if_started({ "local_ai" => local_ai_state })
      remove_state
      exit(0)
    end

    web_service = services.find { |service| service.name == "web" }
    if web_service && signalable_service?(web_service, strict_match: false)
      current_web_state = process_state(web_service.pid)
      if current_web_state && current_web_state != last_web_state
        log("Web process PID #{web_service.pid} state changed #{last_web_state || 'unknown'} -> #{current_web_state}")
      end
      last_web_state = current_web_state

      if current_web_state == "T"
        web_stopped_cycles += 1
        warn_log("Web process PID #{web_service.pid} is stopped (State=T, cycle=#{web_stopped_cycles}). Sending CONT to resume request handling.")
        send_signal_to_service(web_service, "CONT")
      else
        web_stopped_cycles = 0
      end
    end

    begin
      pid, status = Process.waitpid2(-1, Process::WNOHANG)
      if pid
        service = services.find { |entry| entry.pid.to_i == pid.to_i }
        service_name = service ? service.name : "unknown"
        warn_log("#{service_name} exited (pid=#{pid}, status=#{status.inspect}). Shutting down remaining services.")

        graceful_stop_services(services.reject { |entry| entry.pid.to_i == pid.to_i }, reason: "#{service_name} exited")
        stop_local_ai_if_started({ "local_ai" => local_ai_state })
        remove_state

        exit_code = status.exitstatus
        exit_code = 128 + status.termsig.to_i if exit_code.nil? && status.signaled?
        exit(exit_code || 1)
      end
    rescue Errno::ECHILD
      warn_log("No child processes left. Exiting supervisor.")
      stop_local_ai_if_started({ "local_ai" => local_ai_state })
      remove_state
      exit(0)
    end

    sleep(0.4)
  end
end

def ensure_rails_pidfile_consistency!
  pidfile = File.join(ROOT, "tmp", "pids", "server.pid")
  return unless File.exist?(pidfile)

  stopped = stop_rails_from_pidfile(pidfile: pidfile, timeout_seconds: 15)
  if stopped
    log("Stopped existing Rails server from pidfile before startup.")
  elsif File.exist?(pidfile)
    # Keep guard strict when pidfile still points to a live process we could not stop.
    raw = File.read(pidfile).to_s.strip
    pid = Integer(raw) rescue 0
    if pid.positive? && process_alive?(pid)
      raise "Rails server appears to already be running (pid=#{pid}). Run `bin/dev stop` or stop that process first."
    end
    File.delete(pidfile)
  end
end

def health_check
  state = read_state
  if state
    supervisor_pid = state["supervisor_pid"].to_i
    log("Supervisor PID #{supervisor_pid}: #{process_alive?(supervisor_pid) ? 'running' : 'not-running'}")
  else
    log("No dev state file found")
  end

  web_ok = port_open?(WEB_PORT)
  log("Web port #{WEB_PORT}: #{web_ok ? 'open' : 'closed'}")

  snapshot = local_ai_health_snapshot
  log(
    "Local AI: #{snapshot[:ok] ? 'healthy' : 'unhealthy'} " \
    "(microservice=#{snapshot[:microservice_ok] ? 'ok' : 'down'}, " \
    "ollama=#{snapshot[:ollama_ok] ? 'ok' : 'down'})"
  )
  unless snapshot[:ok]
    warn_log("Local AI details: microservice_error=#{snapshot[:microservice_error] || 'none'} ollama_error=#{snapshot[:ollama_error] || 'none'}")
  end

  local_ai_ok = snapshot[:ok] || !local_ai_required?
  exit(web_ok && local_ai_ok ? 0 : 1)
end

COMMANDS = %w[start stop restart status health].freeze

command = if COMMANDS.include?(ARGV.first.to_s)
  ARGV.shift
else
  "start"
end

begin
  case command
  when "start"
    start_stack(ARGV)
  when "stop"
    stop_from_state
  when "restart"
    stop_from_state
    start_stack(ARGV)
  when "status"
    status_from_state
  when "health"
    health_check
  end
rescue StandardError => e
  error_log("#{e.class}: #{e.message}")
  error_log(e.backtrace.first(8).join("\n")) if e.backtrace
  remove_state
  exit(1)
end
